# 工作流规范

## 环境

1. 定义 `development`, `test` 和 `production` 三个环境。
2. 依据不同的环境变量加载部署的相关配置，不要将这些配置作为常量添加到代码库中

#### 一致的开发环境

1. 在 `package.json` 里的 `engines` 中设置您的 `node` 版本
2. 使用 `nvm` 并在您的项目根目录下创建一个 `.nvmrc` 文件。不要忘了在文档中标注
3. 最好设置一个检查 `node` 和 `npm` 版本的 `preinstall` 脚本
4. 使用本地模块，而不是使用全局安装的模块
5. 确保获得完全相同的依赖

## Git

1. 在功能分支中执行开发工作。
2. 从 `develop` 独立出分支。
3. 永远也不要将分支（直接）推送到 `develop` 或者 `master` ，请使用合并请求（`Pull Request`）。
4. 在推送所开发的功能并且发起合并请求前，请更新您本地的 `develop` 分支并且完成交互式变基操作（`interactive rebase`）
5. 请确保在变基并发起合并请求之前解决完潜在的冲突
6. 合并分支后删除本地和远程功能分支
7. 在进行合并请求之前，请确保您的功能分支可以成功构建，并已经通过了所有的测试
8. 使用 `.gitignore` 文件

#### Git 工作流

1. 初始化项目
2. 检出一个新的分支
3. 新增代码变更
4. 保持与远程 `develop` 分支的同步，使得本地 `develop` 分支拿到最新变更
5. 通过交互式变基从 `develop` 分支中获取最新的代码提交，以更新您的功能分支
6. 如果您有冲突, 就需要解决它们并且继续变基操作
7. 推送分支。变基操作会改变提交历史, 所以必须使用 `-f` 强制推送到远程（功能）分支。 如果其他人与您在该分支上进行协同开发，请使用破坏性没那么强的 `--force-with-lease` 参数。
8. 提交一个合并请求 `Pull Request`
9. `Pull Request` 被接受，合并和关闭
10. 删除本地和远程分支

#### Commit Message

1. 用新的空行将标题和主体两者隔开
2. 将标题行限制为 50 个字符，并将主体中一行超过 72 个字符的部分折行显示
3. 标题首字母大写
4. 不要用句号结束标题
5. 在标题中使用 祈使句（与其在写下的信息中描述提交者做了什么，不如将这些描述信息作为在这些提交被应用于该仓库后将要完成的操作的一个说明）
6. 使用主体部分去解释 是什么 和 为什么 而不是 怎么做

## 构建

统一的构建工具链很重要, 这套工具应该强调"约定大于配置"，让开发者更专注于业务的开发。

- 强约定，体现团队的规范。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能。
- 方便升级。尤其是团队需要维护多个项目场景, 这一点很有意义

## 发布

1. 代码变更
1. 提交代码变更到远程版本库
1. 程序通过 `CI` 测试
1. 提升 `package.json` 中的版本
1. 生成 `CHANGELOG`
1. 提交 `package.json` 和 `CHANGELOG.md` 文件
1. 打上 `Tag`
1. 推送

## 持续集成

持续(Continuous), 可以理解为'频繁'或者‘连续性’. 不管是持续集成还是敏捷开发思维、看板，都认为‘持续’是它们的基础。

举一个通俗的例子，比如代码检查，‘持续的’的代码检查就是代码一变动(如保存，或者 IDE 实时检查、或者提交到版本库时)就马上检查代码，而‘非持续’的代码检查就是在完成所有编码后，再进行检查。对比两者可以发现，持续性的代码检查可以尽早地发现错误，而且错误也比较容易理解和处理，反之非持续性的代码检查，可能会发现一堆的错误，失之毫厘谬以千里，错误相互牵连，最终会变得难以收拾。

‘持续’的概念，可以用于软件开发的方方面面，本质上就是把传统瀑布式的软件开发流程打碎，形成一个个更小的开发闭环，持续地输出产品，同时产品也持续地给上游反馈和纠正。广义的持续集成服务，不仅仅是测试，

狭义的集成可以简单认为是‘集成测试’吧. 集成测试可以对代码静态测试、单元测试、通过单元测试后可以进行集成测试，在应用组成一个整体后在模拟环境中跑 E2E 测试等等。也就是说，在这里进行一系列的自动化测试来验证软件系统。广义的持续集成服务，不仅仅是测试，它还衍生出很多概念，例如持续交付、持续部署

![DevOps](../assets/images/standard-DevOps.pngf)

1. 执行的环境. 比如容器、Node 版本、操作系统等等
2. 触发的条件。比如定时触发、在哪个分支触发、会触发什么任务等等
3. 执行的任务
4. 划分持续集成的阶段. 比如
   - 检查：包括单元测试和代码 lint. 所有 push 到版本库的代码都会跑这个阶段. 一般可以在提交 title 中包含[ci skip]来跳过这个阶段
   - 构建: 对前端项目进行构建. 只有打上版本 tag 的提交或 release 分支会跑构建任务
   - 发布: 将前端的构建结果进行交付/发布. 只有打上版本 tag 的提交或者 release 分支在构建成功后会跑发布任务
5. 定义持续集成脚本模板

# 技术栈规范

每一个技术栈都有自己的设计哲学，背后还有一套生态系统，牵涉到开发思维，配套工具，最佳实践等。熟悉一个技术栈的要付出各项成本，根据实际情况选择稳定且熟练的技术栈

1. 编程语言：Typescript 或 Javascript
2. UI 框架
3. 组件库
4. 配套生态
   - 路由
   - 状态管理
   - 国际化
5. 脚手架、CLI 工具
6. 样式：命名规范、预处理器、方法论
7. Lint
8. 格式化工具
9. 包管理器。npm、yarn
10. 时间处理。例如 Moment.js
11. 模板引擎
12. 开发工具
13. 工具库
14. 项目管理工具

## 技术选型

1. 选择你最熟悉的技术。可以很好地控制使用过程中的风险，方便对程序进行调优。所以成员熟悉、或至少 Leader 熟悉程度，是技术选型的一个打分项。
2. 选择拥有强大生态和社区支撑的开源技术。有强大的生态和社区意味着，很多东西你不需要重复去造轮子，或者遇到问题可以很快解决，有更多的选择。
3. 选择成长期的技术。'选择一个技术的最低标准是，技术的生命周期必须显著长于项目的生命周期'
4. API 的稳定性。比较典型的例子就是 Angular 和 Python，API 不稳定会导致社区的割裂，也会导致项目升级成本变高、或者无法升级, 最终成为技术债。
5. 基础设施配合。一个技术往往不是孤立存在的，它需要和其他技术相互配合，这种技术之间的融合度也是需要考虑的。
6. 业务考虑，‘学会从业务端开始思考’. 意思就是选型需要充分地理解业务，理解用户需求，当下需要解决的首要问题，以及可能的风险有哪些，再将目标进行分解，进行具体的技术选型、模型设计、架构设计.

# 项目组织规范

项目组织规范定义了如何组织一个前端项目, 例如项目的命名、项目的文件结构、版本号规范等等。

一个典型的项目组织规范如下:

1. README.md: 项目说明, 这个是最重要。你必须在这里提供关于项目的关键信息或者相关信息的入口. 一般包含下列信息:
1. CHANGELOG.md: 放置每个版本的变动内容, 通常要描述每个版本变更的内容。方便使用者确定应该使用哪个版本
1. package.json: 前端项目必须. 描述当前的版本、可用的命令、包名、依赖、环境约束、项目配置等信息.
1. .gitignore: 忽略不必要的文件，避免将自动生成的文件提交到版本库
1. docs/: 项目的细化文档, 可选.
1. examples/: 项目的示例代码，可选.
1. build: 项目工具类脚本放置在这里，非必须。如果使用统一构建工具，则没有这个目录
1. dist/: 项目构建结果输出目录
1. src/: 源代码目录
1. tests/: 单元测试目录. 按照 Jest 规范, **tests**目录通常和被测试的模块在同一个父目录下, 例如:

```JS
/src
  __tests__/
    index.ts
    a.ts
  index.ts
  a.ts
```

1. tests: 全局的测试目录，通常放应用的集成测试或 E2E 测试等用例
1. .env\*: 项目中我们通常会使用环境变量来影响应用在不同运行环境下的行为. 可以通过 dotEnv 来从文件中读取环境变量. 通常有三个文件:

```
.env 通用的环境变量
.env.development 开发环境的环境变量
.env.production 生成环境的环境变量
```

## 目录组织风格

1. Rails-style: 按照文件的类型划分为不同的目录，例如 components、constants、 typings、views. 这个来源于 Ruby-on-Rails 框架，它按照 MVC 架构来划分不同的目录类型
2. Domain-style: 按照一个功能特性或业务创建单独的目录，这个目录就近包含多种类型的文件或目录
3. Ducks-style: 优点类似于 Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下

**使用 Domain-style 和 Ducks-style 方式**

1. 围绕产品功能/页面/组件，而不是围绕角色来组织文件
2. 使用 ./config 文件夹，不要为不同的环境制作不同的配置文件
3. 将脚本文件放在./scripts 文件夹中。包括 bash 脚本和 node 脚本
4. 文件名和目录名请使用 camelCase 风格。组件请使用 PascalCase 风格
5. CheckBox/index.js 应该代表 CheckBox 组件，也可以写成 CheckBox.js ，但是不能写成冗长的 CheckBox/CheckBox.js 或 checkbox/CheckBox.js
6. 理想情况下，目录名称应该和 index.js 的默认导出名称相匹配。

## 脚手架和模板

项目结构规范确定后，可以创建自定义的脚手架或模板，用于快速初始化一个项目或模板

# 编码规范

统一的编码规范对项目的长远维护不无裨益. 一致性的代码规范可以增强开发协作效率、提高代码质量、减少遗留系统维护的负担。

## JavaScript

#### Lint 工具

`ESLint`，目前是社区最流行的、通用的 Javascript Lint 工具，Lint 界的 Babel。支持定制插件、preset。如果不想折腾可以选择它的一些预定义配置

#### 规范

###### Eslint 配置

[配置手册](https://cn.eslint.org/docs/rules/)，[我的规范](https://github.com/liupeng1218/Pconfig/blob/master/.eslintrc.js)

###### 命名规范

1. 常量：全部大写，使用`_`进行连接，如`MAX_AGE`
2. 变量：使用名词进行命名，小驼峰命名法，如`currentUser`
3. 方法名：使用动词开始，描述意义，小驼峰命名法，如`getInfo`
4. 解决方法：较为复杂的函数方法，声明注释，参数及返回内容

###### Vue

**data**

1. `D`：动态渲染数据
2. `F`：表单数据
3. `O`：表单，图表等组件配置数据
4. `S`：控制组件显示/隐藏

**methods**

1. `H`：事件钩子
2. `P`：内部事件
3. `M`：mixin 事件

#### 类型检查

`TypeScript`，Javascript 语言的超集，这是一门‘新’的语言，而不是简单的类型检查器. 不过它也支持原生 Javascript 的类型检查

## HTML

#### 规范

1. 结构内容使用`BEM`命名规范
2. 动态数据内容使用`D(data)`前缀配合数据说明命名，如`Duser-name`
3. 事件触发元素使用`H(handle)`前缀配合动作说明命名，如`Hquery-table`
4. 表单数据元素使用`F(form)`前缀配合表单参数类型，如`Fbuy-quantity`

## CSS

#### Lint 工具

`stylelint`，通用的 CSS 编码检查工具，支持最新的 CSS 语法、CSS-in-js、以及其他类 CSS 语法(如 SCSS、Less). 它也有预定义配置，推荐使用

#### 方法论

使用`BEM`规范，主要规则为

`.[Mod 模块]-[Block 块]__[Element 元素]--[Modifier 修饰符]`

###### 模块

模块代表当前命名空间，如一套组件组，使用字符前缀,如`fa-`

###### 块

1. 块名需能清晰的表达出，其用途、功能或意义，具有唯一性。
2. 块名称之间用`-`连接。
3. 每个块名前应增加一个前缀，这前缀在 CSS 中有命名空间（如：m-、u-、分别代表：mod 模块、ui 元件）。
4. 每个块在逻辑上和功能上都相互独立。
5. 由于块是独立的，可以在应用开发中进行复用，从而降低代码重复并提高开发效率。
6. 块可以放置在页面上的任何位置，也可以互相嵌套。
7. 同类型的块，在显示上可能会有一定的差异，所以不要定义过多的外观显示样式，主要负责结构的呈现。

###### 元素

1. 元素名需能简单的描述出，其结构、布局或意义，并且在语义上与块相关联。
1. 块与元素之间用`__`连接。
1. 不能与块分开单独使用。
1. 块的内部元素，都被认为是块的子元素。
1. 一个块中元素的类名必须用父级块的名称作为前缀，因此不能写成：`block__elem1__elem2`。

###### 修饰符

1. 修饰符需能直观易懂表达出，其外观、状态或行为。
1. 修饰符用`--`连接块与元素。
1. 修饰符不能单独使用。
1. 在必要时可进行扩展，书写成：`block__elem--modifier-modifier`

## 格式化

**Prettier**  
关于代码格式化的所有东西都交给它吧！  
在`Javascript`中配合`Eslint`使用，注意冲突问题 [配置](https://github.com/liupeng1218/Pconfig/blob/master/.prettierrc.js)

# UI 设计规范

没有所谓的设计规范，就会导致设计出来的产品都是东借西凑，前后不统一，多个应用之间的组件不能复用。

UI 设计规范的意义：

1. 提供团队协作效率(产品和开发)
1. 提高组件的复用率. 统一的组件规范可以让组件更好管理
1. 保持产品迭代过程中品牌一致性
