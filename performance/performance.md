<!-- TOC -->

- [网络层](#网络层)
  - [静态文件](#静态文件)
  - [图片](#图片)
  - [缓存](#缓存)
    - [缓存位置](#缓存位置)
    - [缓存策略](#缓存策略)
      - [强缓存](#强缓存)
      - [协商缓存](#协商缓存)
        - [Last-Modified 和 If-Modified-Since](#last-modified-和-if-modified-since)
        - [ETag 和 If-None-Match](#etag-和-if-none-match)
        - [默认策略](#默认策略)
    - [决策指南](#决策指南)
      - [频繁变动的资源](#频繁变动的资源)
      - [代码文件](#代码文件)
  - [DNS 预解析](#dns-预解析)
  - [CDN](#cdn)
  - [按需加载/懒加载](#按需加载懒加载)
- [渲染层](#渲染层)
  - [渲染流程](#渲染流程)
  - [结构树](#结构树)
  - [渲染阻塞](#渲染阻塞)
      - [CSS 阻塞](#css-阻塞)
      - [JS 阻塞](#js-阻塞)
  - [CSS 优化](#css-优化)
  - [DOM](#dom)
  - [回流和重绘](#回流和重绘)
      - [避免回流和重绘](#避免回流和重绘)
- [性能监测](#性能监测)
  - [Performance](#performance)
  - [LightHouse](#lighthouse)
- [总结](#总结)

<!-- /TOC -->

一个 url 从输入到页面加载完成经历：

1. DNS 解析
2. TCP 链接
3. HTTP 请求
4. 服务端接收请求，处理返回
5. 浏览器获取数据，解析响应内容，渲染内容

性能的的优化也就在是在这些过程中，逐个分解，各个击破。

![performance](../assets/images/performance.jpg)

# 网络层

网络层面主要分为 3 个过程

- DNS 解析
- TCP 链接
- HTTP 请求/响应

HTTP 是前端在网络层优化的主要核心：

- 减少请求次数
- 减少单次请求所需时间

这两个优化点直直地指向了我们日常开发中非常常见的操作——资源的压缩与合并。

## 静态文件

- 第三方库使用 min 版本
- 压缩静态 js,css
- 提取合并公共资源

## 图片

- 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
- 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
- 小图使用 base64 格式
- 将多个图标文件整合到一张图片中（雪碧图）
- 压缩图片

## 缓存

缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

### 缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络

- Memory Cache
- Service Worker
- Disk Cache
- Push Cache

1. Memory Cache：内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
2. Disk Cache： 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。
3. 网络请求

如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。

### 缓存策略

通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 `HTTP Header` 来实现的。

#### 强缓存

强缓存可以通过设置两种 `HTTP Header` 实现：`Expires`和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。

1. Expires

`Expires: Wed, 22 Oct 2018 08:41:00 GMT`

`Expires` 是 `HTTP/1` 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

2. Cache-control

![Cache-Control](../assets/images/browser-CacheControl.png)

`Cache-Control` 出现于 `HTTP/1.1`，优先级高于 `Expires` 。

`Cache-control: max-age=30, s-maxage=31536000`

- `max-age`：控制缓存的有效期
- `no-cache`：不再命中强缓存，直接走协商缓存
- `no-store`：不使用任何缓存策略，直接向服务器发起资源请求

#### 协商缓存

协商缓存依赖于服务端与浏览器之间的通信。

协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。

如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 `HTTP Header` 实现：`Last-Modified`和 `ETag` 。

当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 `304` 状态码，并且更新浏览器缓存有效期。

##### Last-Modified 和 If-Modified-Since

`Last-Modified` 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 `Response Headers` 返回：

`Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT`

随后我们每次请求时，会带上一个叫 `If-Modified-Sinc`e 的时间戳字段，它的值正是上一次 `response` 返回给它的 `last-modified` 值：

`If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT`

服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 `Response Headers` 中添加新的 `Last-Modified` 值；否则，返回如上图的 `304` 响应，`Response Headers` 不会再添加 `Last-Modified` 字段。

**Last-Modified 存在一些弊端**：

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified`被修改
- 当我们修改文件的速度过快时（比如花了 `100ms` 完成了改动），由于 `If-Modified-Since` 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。

##### ETag 和 If-None-Match

`Etag` 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 `Etag` 就是不同的，反之亦然。因此 `Etag` 能够精准地感知文件的变化。 `Etag` 和 `Last-Modified` 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串：

`ETag: W/"af85-g9aQBXnMbirQuH0OsPN2wnB6Dzo"`

那么下一次请求时，请求头里就会带上一个值相同的、名为 `if-None-Match` 的字符串供服务端比对了：

`If-None-Match: W/"af85-g9aQBXnMbirQuH0OsPN2wnB6Dzo"`

##### 默认策略

浏览器会采用一个启发式的算法，通常会取响应头中的 `Date` 减去 `Last-Modified` 值的 `10%` 作为缓存时间。

### 决策指南

![performance_cache](../assets/images/performance_cache.jpg)

1. 当我们的资源内容不可复用时，直接为 `Cache-Control` 设置 `no-store`，拒绝一切形式的缓存；
2. 否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 `Cache-Control` 的值为 `no-cache`；
3. 否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 `private` 还是 `public`；
4. 然后考虑该资源的过期时间，设置对应的 `max-age` 和 `s-maxage` 值；
5. 最后，配置协商缓存需要用到的 `Etag`、`Last-Modified` 等参数。

#### 频繁变动的资源

对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

#### 代码文件

这里特指除了 `HTML` 外的代码文件，因为 `HTML` 文件一般不缓存或者缓存时间很短。

一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 `Cache-Control: max-age=31536000`，这样只有当 `HTML` 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。

## DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

## CDN

CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。

- 可以将静态资源尽量使用 CDN 加载，可以快速响应服务返回资源
- 使用多个 CDN 域名，突破浏览器对于单个域名并发请求上限。注意 CDN 域名要与主站不同，避免每次请求都会带上主站的 Cookie，浪费资源

## 按需加载/懒加载

按需加载/懒加载就是将不关键的资源延后加载。

如路由模块可以做成异步路由，待跳转时再进行加载  
懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。

# 渲染层

## 渲染流程

1. 解析 HTML：在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。
2. 计算样式：浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。
3. 计算图层布局：页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。
4. 绘制图层：在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。
5. 整合图层，得到页面：最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。

## 结构树

![performance_render](../assets/images/performance_render.png)

1. DOM 树：解析 HTML 以创建的是 DOM 树（DOM tree ）：渲染引擎开始解析 HTML 文档，转换树中的标签到 DOM 节点，它被称为“内容树”。
1. CSSOM 树：解析 CSS（包括外部 CSS 文件和样式元素）创建的是 CSSOM 树。CSSOM 的解析过程与 DOM 的解析过程是并行的。
1. 渲染树：CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）。
1. 布局渲染树：从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，我们便得到了基于渲染树的布局渲染树（Layout of the render tree）。
1. 绘制渲染树: 遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）。

渲染过程说白了，首先是基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。之后每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它。

## 渲染阻塞

#### CSS 阻塞

DOM 和 CSSOM 合力才能构建渲染树。这一点会给性能造成严重影响：默认情况下，**CSS 是阻塞的资源**。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK（这主要是为了避免没有 CSS 的 HTML 页面丑陋地“裸奔”在用户眼前）。 CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。**将 CSS 文件放置在 head 标签内，使用 CDN 加速等服务**。

#### JS 阻塞

JS 引擎是独立于渲染引擎存在的。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。

- 正常模式： JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕
- async 模式：async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。执行时会阻塞渲染
- defer 模式：defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。

## CSS 优化

**CSS 选择符是从右到左进行匹配的**

- 避免使用通配符，只对需要用到的元素进行选择。
- 关注可以通过继承实现的属性，避免重复匹配重复定义。
- 少用标签选择器。如果可以，用类选择器替代

## DOM 

**DOM 为什么这么慢**

1. DOM 操作涉及到JS引擎和渲染引擎两个部分的的联合操作，有联合成本
2. 对DOM修改会引起回流和重绘

**减少 DOM 操作，对DOM加速**

## 回流和重绘

回流：对 DOM 的修改引发了 DOM 几何尺寸的变化
重绘：对 DOM 的修改导致了样式的变化、却并未影响其几何属性

#### 避免回流和重绘

1. 将“导火索”缓存起来，避免频繁改动
2. 避免逐条改变样式，使用类名去合并样式
3. 将 DOM “离线”


# 性能监测

## Performance

Performance 是 Chrome 提供给我们的开发者工具，用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。

## LightHouse

Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。


# 总结

**网络**
减少请求次数和请求时间

1. 压缩静态资源
2. 合并公共资源
3. 使用合适体积的图片
4. 使用css和base64格式替代图片 
5. 合理使用缓存，频繁变动资源使用`no-cache`配合协商缓存，代码文件使用文件指纹配置长时间强缓存
6. 使用按需加载（异步路由），懒加载（图片可视显示）
7. 使用CDN加速静态资源，突破并发上限

**渲染**

1. css优化，合理使用选择器，精准定位
2. 减少dom操作，避免联合操作和回流重绘消耗性能