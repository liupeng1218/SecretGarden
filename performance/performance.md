<!-- TOC -->

- [网络层](#网络层)
- [渲染层](#渲染层)
- [性能监测](#性能监测)
- [最佳实践](#最佳实践)
- [DNS 预解析](#dns-预解析)
- [CDN](#cdn)
- [懒加载](#懒加载)
- [文件](#文件)
  - [图片](#图片)
  - [css,js](#cssjs)
- [防抖节流](#防抖节流)
  - [防抖](#防抖)
    - [场景](#场景)
  - [节流](#节流)

<!-- /TOC -->

一个url从输入到页面加载完成经历：
1. dns解析
2. tpc链接
3. http请求
4. 服务端接收请求，处理返回
5. 浏览器获取数据，解析响应内容，渲染内容

性能的的优化也就在是在这些过程中，逐个分解，各个击破

# 网络层

# 渲染层

# 性能监测

# 最佳实践

性能的核心在于减少请求次数和减少资源体积

# DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

# CDN

我们可以将静态资源尽量使用 CDN 加载
使用多个 CDN 域名，突破浏览器对于单个域名并发请求上限
注意 CDN 域名要与主站不同，避免每次请求都会带上主站的 Cookie，浪费资源

# 懒加载

懒加载就是将不关键的资源延后加载。

懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。
对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

# 文件

## 图片

- 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
- 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
- 小图使用 base64 格式
- 将多个图标文件整合到一张图片中（雪碧图）
- 压缩图片

## css,js

- 压缩静态 js,css
- 第三方库使用 min 版本
- 提取合并公共资源

# 防抖节流

## 防抖

防抖是当用户触发事件后，延迟时间后再执行，如果在延迟时间内再次触发则重置延迟时间

```JS
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}
```

### 场景

`resize`事件监控响应

## 节流

节流是指用户不断触发事件，事件总以特定的延迟间隔进行触发

```JS
// func是用户传入需要防抖的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
  // 上一次执行该函数的时间
  let lastTime = 0
  return function(...args) {
    // 当前时间
    let now = +new Date()
    // 将当前时间和上一次执行函数时间对比
    // 如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now
      func.apply(this, args)
    }
  }
}

setInterval(
  throttle(() => {
    console.log(1)
  }, 500),
  1
)
```